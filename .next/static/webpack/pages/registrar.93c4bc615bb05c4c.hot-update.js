"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/registrar",{

/***/ "(pages-dir-browser)/./src/front-end/servicos/ServicoAutenticacao.ts":
/*!*******************************************************!*\
  !*** ./src/front-end/servicos/ServicoAutenticacao.ts ***!
  \*******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ServicoAutenticacao: () => (/* binding */ ServicoAutenticacao)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\r\n * Serviço de autenticação para o front-end\r\n * Responsável por comunicação com o MCP de autenticação\r\n */ class ServicoAutenticacao {\n    /**\r\n   * Realiza o login do usuário\r\n   * @param email Email do usuário\r\n   * @param senha Senha do usuário\r\n   * @returns Token JWT em caso de sucesso\r\n   * @throws Error em caso de falha\r\n   */ async login(email, senha) {\n        // Se estiver em modo de simulação, usar dados simulados\n        if (this.modoSimulacao) {\n            console.log('Usando modo de simulação para login');\n            // Simular um pequeno atraso para parecer uma requisição real\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            const usuario = this.usuariosSimulados[email];\n            if (!usuario) {\n                throw new Error('Usuário não encontrado');\n            }\n            if (usuario.senha !== senha) {\n                throw new Error('Senha incorreta');\n            }\n            // Gerar um token simulado\n            const token = \"simulado-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 15));\n            // Armazenar o token no localStorage\n            localStorage.setItem('token', token);\n            localStorage.setItem('usuario', JSON.stringify({\n                id: \"user-\".concat(Math.random().toString(36).substring(2, 9)),\n                nome: usuario.nome,\n                email: usuario.email\n            }));\n            return token;\n        }\n        // Se não estiver em modo de simulação, tentar conectar ao servidor real\n        try {\n            const resposta = await fetch(\"\".concat(this.baseUrl, \"/login\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    email,\n                    senha\n                })\n            });\n            const dados = await resposta.json();\n            if (!resposta.ok) {\n                throw new Error(dados.message || 'Erro ao realizar login');\n            }\n            // Armazenar o token no localStorage\n            localStorage.setItem('token', dados.token);\n            return dados.token;\n        } catch (erro) {\n            console.error('Erro no login:', erro);\n            // Se o erro for de conexão, tentar usar o modo de simulação\n            if (erro instanceof TypeError && erro.message.includes('Failed to fetch')) {\n                console.log('Servidor indisponível, alternando para modo de simulação');\n                this.modoSimulacao = true;\n                return this.login(email, senha);\n            }\n            throw erro;\n        }\n    }\n    /**\r\n   * Registra um novo usuário\r\n   * @param nome Nome do usuário\r\n   * @param email Email do usuário\r\n   * @param senha Senha do usuário\r\n   * @returns Dados do usuário criado\r\n   * @throws Error em caso de falha\r\n   */ async registrar(nome, email, senha) {\n        // Se estiver em modo de simulação, usar dados simulados\n        if (this.modoSimulacao) {\n            console.log('Usando modo de simulação para registro');\n            // Simular um pequeno atraso para parecer uma requisição real\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            // Verificar se o email já está em uso\n            if (this.usuariosSimulados[email]) {\n                throw new Error('Este email já está em uso');\n            }\n            // Adicionar o novo usuário à lista de usuários simulados\n            this.usuariosSimulados[email] = {\n                nome,\n                email,\n                senha\n            };\n            // Retornar os dados do usuário criado (sem a senha)\n            return {\n                id: \"user-\".concat(Math.random().toString(36).substring(2, 9)),\n                nome,\n                email,\n                message: 'Usuário registrado com sucesso!'\n            };\n        }\n        // Se não estiver em modo de simulação, tentar conectar ao servidor real\n        try {\n            const resposta = await fetch(\"\".concat(this.baseUrl, \"/registrar\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    nome,\n                    email,\n                    senha\n                })\n            });\n            const dados = await resposta.json();\n            if (!resposta.ok) {\n                throw new Error(dados.message || 'Erro ao registrar usuário');\n            }\n            return dados;\n        } catch (erro) {\n            console.error('Erro no registro:', erro);\n            // Se o erro for de conexão, tentar usar o modo de simulação\n            if (erro instanceof TypeError && erro.message.includes('Failed to fetch')) {\n                console.log('Servidor indisponível, alternando para modo de simulação');\n                this.modoSimulacao = true;\n                return this.registrar(nome, email, senha);\n            }\n            throw erro;\n        }\n    }\n    /**\r\n   * Solicita recuperação de senha\r\n   * @param email Email do usuário\r\n   * @returns Mensagem de sucesso\r\n   * @throws Error em caso de falha\r\n   */ async recuperarSenha(email) {\n        // Se estiver em modo de simulação, usar dados simulados\n        if (this.modoSimulacao) {\n            console.log('Usando modo de simulação para recuperação de senha');\n            // Simular um pequeno atraso para parecer uma requisição real\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            // Verificar se o email existe\n            if (!this.usuariosSimulados[email]) {\n                // Por segurança, não informamos se o email existe ou não\n                return 'Se o e-mail estiver cadastrado, enviaremos instruções para recuperação de senha.';\n            }\n            // Simular um token de recuperação\n            const token = \"recuperacao-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 15));\n            console.log(\"Token de recupera\\xe7\\xe3o simulado para \".concat(email, \": \").concat(token));\n            return 'Se o e-mail estiver cadastrado, enviaremos instruções para recuperação de senha.';\n        }\n        // Se não estiver em modo de simulação, tentar conectar ao servidor real\n        try {\n            const resposta = await fetch(\"\".concat(this.baseUrl, \"/recuperar-senha\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    email\n                })\n            });\n            const dados = await resposta.json();\n            if (!resposta.ok) {\n                throw new Error(dados.message || 'Erro ao solicitar recuperação de senha');\n            }\n            return dados.message;\n        } catch (erro) {\n            console.error('Erro na recuperação de senha:', erro);\n            // Se o erro for de conexão, tentar usar o modo de simulação\n            if (erro instanceof TypeError && erro.message.includes('Failed to fetch')) {\n                console.log('Servidor indisponível, alternando para modo de simulação');\n                this.modoSimulacao = true;\n                return this.recuperarSenha(email);\n            }\n            throw erro;\n        }\n    }\n    /**\r\n   * Redefine a senha do usuário\r\n   * @param senha Nova senha\r\n   * @param token Token de redefinição de senha\r\n   * @returns Mensagem de sucesso\r\n   * @throws Error em caso de falha\r\n   */ async redefinirSenha(senha, token) {\n        // Se estiver em modo de simulação, usar dados simulados\n        if (this.modoSimulacao) {\n            console.log('Usando modo de simulação para redefinição de senha');\n            // Simular um pequeno atraso para parecer uma requisição real\n            await new Promise((resolve)=>setTimeout(resolve, 500));\n            // Verificar se o token é válido (em um caso real, verificaríamos em um banco de dados)\n            if (!token.startsWith('recuperacao-')) {\n                throw new Error('Token inválido ou expirado');\n            }\n            // Em um caso real, atualizaríamos a senha do usuário no banco de dados\n            console.log(\"Senha redefinida com sucesso usando o token: \".concat(token));\n            return 'Senha redefinida com sucesso!';\n        }\n        // Se não estiver em modo de simulação, tentar conectar ao servidor real\n        try {\n            const resposta = await fetch(\"\".concat(this.baseUrl, \"/redefinir-senha\"), {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    senha,\n                    token\n                })\n            });\n            const dados = await resposta.json();\n            if (!resposta.ok) {\n                throw new Error(dados.message || 'Erro ao redefinir senha');\n            }\n            return dados.message;\n        } catch (erro) {\n            console.error('Erro na redefinição de senha:', erro);\n            // Se o erro for de conexão, tentar usar o modo de simulação\n            if (erro instanceof TypeError && erro.message.includes('Failed to fetch')) {\n                console.log('Servidor indisponível, alternando para modo de simulação');\n                this.modoSimulacao = true;\n                return this.redefinirSenha(senha, token);\n            }\n            throw erro;\n        }\n    }\n    /**\r\n   * Verifica se o usuário está autenticado\r\n   * @returns true se o usuário estiver autenticado, false caso contrário\r\n   */ estaAutenticado() {\n        if (false) {}\n        const token = localStorage.getItem('token');\n        return !!token;\n    }\n    /**\r\n   * Realiza o logout do usuário\r\n   */ logout() {\n        if (false) {}\n        localStorage.removeItem('token');\n        localStorage.removeItem('usuario');\n    }\n    /**\r\n   * Obtém o token JWT armazenado\r\n   * @returns Token JWT ou null se não estiver autenticado\r\n   */ obterToken() {\n        if (false) {}\n        return localStorage.getItem('token');\n    }\n    /**\r\n   * Obtém os dados do usuário autenticado\r\n   * @returns Dados do usuário ou null se não estiver autenticado\r\n   */ obterUsuario() {\n        if (false) {}\n        const usuarioJson = localStorage.getItem('usuario');\n        if (!usuarioJson) {\n            return null;\n        }\n        try {\n            return JSON.parse(usuarioJson);\n        } catch (erro) {\n            console.error('Erro ao obter dados do usuário:', erro);\n            return null;\n        }\n    }\n    constructor(){\n        // URL base do MCP de autenticação\n        this.baseUrl = process.env.NEXT_PUBLIC_AUTH_API_URL || 'http://localhost:3001';\n        // Verificar se devemos usar o modo de simulação (quando o servidor não está disponível)\n        this.modoSimulacao = process.env.NEXT_PUBLIC_MODO_SIMULACAO === 'true' || true;\n        // Usuários simulados para testes\n        this.usuariosSimulados = {\n            'admin@exemplo.com': {\n                nome: 'Administrador',\n                email: 'admin@exemplo.com',\n                senha: 'senha123'\n            },\n            'fornecedor@exemplo.com': {\n                nome: 'Fornecedor Teste',\n                email: 'fornecedor@exemplo.com',\n                senha: 'senha123'\n            },\n            'representante@exemplo.com': {\n                nome: 'Representante Teste',\n                email: 'representante@exemplo.com',\n                senha: 'senha123'\n            }\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL3NyYy9mcm9udC1lbmQvc2Vydmljb3MvU2Vydmljb0F1dGVudGljYWNhby50cyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Q0FHQyxHQUNNLE1BQU1BO0lBb0JYOzs7Ozs7R0FNQyxHQUNELE1BQWFDLE1BQU1DLEtBQWEsRUFBRUMsS0FBYSxFQUFtQjtRQUNoRSx3REFBd0Q7UUFDeEQsSUFBSSxJQUFJLENBQUNDLGFBQWEsRUFBRTtZQUN0QkMsUUFBUUMsR0FBRyxDQUFDO1lBRVosNkRBQTZEO1lBQzdELE1BQU0sSUFBSUMsUUFBUUMsQ0FBQUEsVUFBV0MsV0FBV0QsU0FBUztZQUVqRCxNQUFNRSxVQUFVLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNULE1BQU07WUFFN0MsSUFBSSxDQUFDUSxTQUFTO2dCQUNaLE1BQU0sSUFBSUUsTUFBTTtZQUNsQjtZQUVBLElBQUlGLFFBQVFQLEtBQUssS0FBS0EsT0FBTztnQkFDM0IsTUFBTSxJQUFJUyxNQUFNO1lBQ2xCO1lBRUEsMEJBQTBCO1lBQzFCLE1BQU1DLFFBQVEsWUFBMEJDLE9BQWRDLEtBQUtDLEdBQUcsSUFBRyxLQUErQyxPQUE1Q0YsS0FBS0csTUFBTSxHQUFHQyxRQUFRLENBQUMsSUFBSUMsU0FBUyxDQUFDLEdBQUc7WUFFaEYsb0NBQW9DO1lBQ3BDQyxhQUFhQyxPQUFPLENBQUMsU0FBU1I7WUFDOUJPLGFBQWFDLE9BQU8sQ0FBQyxXQUFXQyxLQUFLQyxTQUFTLENBQUM7Z0JBQzdDQyxJQUFJLFFBQW1ELE9BQTNDVixLQUFLRyxNQUFNLEdBQUdDLFFBQVEsQ0FBQyxJQUFJQyxTQUFTLENBQUMsR0FBRztnQkFDcERNLE1BQU1mLFFBQVFlLElBQUk7Z0JBQ2xCdkIsT0FBT1EsUUFBUVIsS0FBSztZQUN0QjtZQUVBLE9BQU9XO1FBQ1Q7UUFFQSx3RUFBd0U7UUFDeEUsSUFBSTtZQUNGLE1BQU1hLFdBQVcsTUFBTUMsTUFBTSxHQUFnQixPQUFiLElBQUksQ0FBQ0MsT0FBTyxFQUFDLFdBQVM7Z0JBQ3BEQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU1ULEtBQUtDLFNBQVMsQ0FBQztvQkFBRXJCO29CQUFPQztnQkFBTTtZQUN0QztZQUVBLE1BQU02QixRQUFRLE1BQU1OLFNBQVNPLElBQUk7WUFFakMsSUFBSSxDQUFDUCxTQUFTUSxFQUFFLEVBQUU7Z0JBQ2hCLE1BQU0sSUFBSXRCLE1BQU1vQixNQUFNRyxPQUFPLElBQUk7WUFDbkM7WUFFQSxvQ0FBb0M7WUFDcENmLGFBQWFDLE9BQU8sQ0FBQyxTQUFTVyxNQUFNbkIsS0FBSztZQUV6QyxPQUFPbUIsTUFBTW5CLEtBQUs7UUFDcEIsRUFBRSxPQUFPdUIsTUFBTTtZQUNiL0IsUUFBUWdDLEtBQUssQ0FBQyxrQkFBa0JEO1lBRWhDLDREQUE0RDtZQUM1RCxJQUFJQSxnQkFBZ0JFLGFBQWFGLEtBQUtELE9BQU8sQ0FBQ0ksUUFBUSxDQUFDLG9CQUFvQjtnQkFDekVsQyxRQUFRQyxHQUFHLENBQUM7Z0JBQ1osSUFBSSxDQUFDRixhQUFhLEdBQUc7Z0JBQ3JCLE9BQU8sSUFBSSxDQUFDSCxLQUFLLENBQUNDLE9BQU9DO1lBQzNCO1lBRUEsTUFBTWlDO1FBQ1I7SUFDRjtJQUVBOzs7Ozs7O0dBT0MsR0FDRCxNQUFhSSxVQUFVZixJQUFZLEVBQUV2QixLQUFhLEVBQUVDLEtBQWEsRUFBZ0I7UUFDL0Usd0RBQXdEO1FBQ3hELElBQUksSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDdEJDLFFBQVFDLEdBQUcsQ0FBQztZQUVaLDZEQUE2RDtZQUM3RCxNQUFNLElBQUlDLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFFakQsc0NBQXNDO1lBQ3RDLElBQUksSUFBSSxDQUFDRyxpQkFBaUIsQ0FBQ1QsTUFBTSxFQUFFO2dCQUNqQyxNQUFNLElBQUlVLE1BQU07WUFDbEI7WUFFQSx5REFBeUQ7WUFDekQsSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQ1QsTUFBTSxHQUFHO2dCQUFFdUI7Z0JBQU12QjtnQkFBT0M7WUFBTTtZQUVyRCxvREFBb0Q7WUFDcEQsT0FBTztnQkFDTHFCLElBQUksUUFBbUQsT0FBM0NWLEtBQUtHLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHO2dCQUNwRE07Z0JBQ0F2QjtnQkFDQWlDLFNBQVM7WUFDWDtRQUNGO1FBRUEsd0VBQXdFO1FBQ3hFLElBQUk7WUFDRixNQUFNVCxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQyxlQUFhO2dCQUN4REMsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNVCxLQUFLQyxTQUFTLENBQUM7b0JBQUVFO29CQUFNdkI7b0JBQU9DO2dCQUFNO1lBQzVDO1lBRUEsTUFBTTZCLFFBQVEsTUFBTU4sU0FBU08sSUFBSTtZQUVqQyxJQUFJLENBQUNQLFNBQVNRLEVBQUUsRUFBRTtnQkFDaEIsTUFBTSxJQUFJdEIsTUFBTW9CLE1BQU1HLE9BQU8sSUFBSTtZQUNuQztZQUVBLE9BQU9IO1FBQ1QsRUFBRSxPQUFPSSxNQUFNO1lBQ2IvQixRQUFRZ0MsS0FBSyxDQUFDLHFCQUFxQkQ7WUFFbkMsNERBQTREO1lBQzVELElBQUlBLGdCQUFnQkUsYUFBYUYsS0FBS0QsT0FBTyxDQUFDSSxRQUFRLENBQUMsb0JBQW9CO2dCQUN6RWxDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixJQUFJLENBQUNGLGFBQWEsR0FBRztnQkFDckIsT0FBTyxJQUFJLENBQUNvQyxTQUFTLENBQUNmLE1BQU12QixPQUFPQztZQUNyQztZQUVBLE1BQU1pQztRQUNSO0lBQ0Y7SUFFQTs7Ozs7R0FLQyxHQUNELE1BQWFLLGVBQWV2QyxLQUFhLEVBQW1CO1FBQzFELHdEQUF3RDtRQUN4RCxJQUFJLElBQUksQ0FBQ0UsYUFBYSxFQUFFO1lBQ3RCQyxRQUFRQyxHQUFHLENBQUM7WUFFWiw2REFBNkQ7WUFDN0QsTUFBTSxJQUFJQyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO1lBRWpELDhCQUE4QjtZQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDRyxpQkFBaUIsQ0FBQ1QsTUFBTSxFQUFFO2dCQUNsQyx5REFBeUQ7Z0JBQ3pELE9BQU87WUFDVDtZQUVBLGtDQUFrQztZQUNsQyxNQUFNVyxRQUFRLGVBQTZCQyxPQUFkQyxLQUFLQyxHQUFHLElBQUcsS0FBK0MsT0FBNUNGLEtBQUtHLE1BQU0sR0FBR0MsUUFBUSxDQUFDLElBQUlDLFNBQVMsQ0FBQyxHQUFHO1lBRW5GZCxRQUFRQyxHQUFHLENBQUMsNENBQWdETyxPQUFWWCxPQUFNLE1BQVUsT0FBTlc7WUFFNUQsT0FBTztRQUNUO1FBRUEsd0VBQXdFO1FBQ3hFLElBQUk7WUFDRixNQUFNYSxXQUFXLE1BQU1DLE1BQU0sR0FBZ0IsT0FBYixJQUFJLENBQUNDLE9BQU8sRUFBQyxxQkFBbUI7Z0JBQzlEQyxRQUFRO2dCQUNSQyxTQUFTO29CQUNQLGdCQUFnQjtnQkFDbEI7Z0JBQ0FDLE1BQU1ULEtBQUtDLFNBQVMsQ0FBQztvQkFBRXJCO2dCQUFNO1lBQy9CO1lBRUEsTUFBTThCLFFBQVEsTUFBTU4sU0FBU08sSUFBSTtZQUVqQyxJQUFJLENBQUNQLFNBQVNRLEVBQUUsRUFBRTtnQkFDaEIsTUFBTSxJQUFJdEIsTUFBTW9CLE1BQU1HLE9BQU8sSUFBSTtZQUNuQztZQUVBLE9BQU9ILE1BQU1HLE9BQU87UUFDdEIsRUFBRSxPQUFPQyxNQUFNO1lBQ2IvQixRQUFRZ0MsS0FBSyxDQUFDLGlDQUFpQ0Q7WUFFL0MsNERBQTREO1lBQzVELElBQUlBLGdCQUFnQkUsYUFBYUYsS0FBS0QsT0FBTyxDQUFDSSxRQUFRLENBQUMsb0JBQW9CO2dCQUN6RWxDLFFBQVFDLEdBQUcsQ0FBQztnQkFDWixJQUFJLENBQUNGLGFBQWEsR0FBRztnQkFDckIsT0FBTyxJQUFJLENBQUNxQyxjQUFjLENBQUN2QztZQUM3QjtZQUVBLE1BQU1rQztRQUNSO0lBQ0Y7SUFFQTs7Ozs7O0dBTUMsR0FDRCxNQUFhTSxlQUFldkMsS0FBYSxFQUFFVSxLQUFhLEVBQW1CO1FBQ3pFLHdEQUF3RDtRQUN4RCxJQUFJLElBQUksQ0FBQ1QsYUFBYSxFQUFFO1lBQ3RCQyxRQUFRQyxHQUFHLENBQUM7WUFFWiw2REFBNkQ7WUFDN0QsTUFBTSxJQUFJQyxRQUFRQyxDQUFBQSxVQUFXQyxXQUFXRCxTQUFTO1lBRWpELHVGQUF1RjtZQUN2RixJQUFJLENBQUNLLE1BQU04QixVQUFVLENBQUMsaUJBQWlCO2dCQUNyQyxNQUFNLElBQUkvQixNQUFNO1lBQ2xCO1lBRUEsdUVBQXVFO1lBQ3ZFUCxRQUFRQyxHQUFHLENBQUMsZ0RBQXNELE9BQU5PO1lBRTVELE9BQU87UUFDVDtRQUVBLHdFQUF3RTtRQUN4RSxJQUFJO1lBQ0YsTUFBTWEsV0FBVyxNQUFNQyxNQUFNLEdBQWdCLE9BQWIsSUFBSSxDQUFDQyxPQUFPLEVBQUMscUJBQW1CO2dCQUM5REMsUUFBUTtnQkFDUkMsU0FBUztvQkFDUCxnQkFBZ0I7Z0JBQ2xCO2dCQUNBQyxNQUFNVCxLQUFLQyxTQUFTLENBQUM7b0JBQUVwQjtvQkFBT1U7Z0JBQU07WUFDdEM7WUFFQSxNQUFNbUIsUUFBUSxNQUFNTixTQUFTTyxJQUFJO1lBRWpDLElBQUksQ0FBQ1AsU0FBU1EsRUFBRSxFQUFFO2dCQUNoQixNQUFNLElBQUl0QixNQUFNb0IsTUFBTUcsT0FBTyxJQUFJO1lBQ25DO1lBRUEsT0FBT0gsTUFBTUcsT0FBTztRQUN0QixFQUFFLE9BQU9DLE1BQU07WUFDYi9CLFFBQVFnQyxLQUFLLENBQUMsaUNBQWlDRDtZQUUvQyw0REFBNEQ7WUFDNUQsSUFBSUEsZ0JBQWdCRSxhQUFhRixLQUFLRCxPQUFPLENBQUNJLFFBQVEsQ0FBQyxvQkFBb0I7Z0JBQ3pFbEMsUUFBUUMsR0FBRyxDQUFDO2dCQUNaLElBQUksQ0FBQ0YsYUFBYSxHQUFHO2dCQUNyQixPQUFPLElBQUksQ0FBQ3NDLGNBQWMsQ0FBQ3ZDLE9BQU9VO1lBQ3BDO1lBRUEsTUFBTXVCO1FBQ1I7SUFDRjtJQUVBOzs7R0FHQyxHQUNELGtCQUFrQztRQUNoQyxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7UUFFRCxNQUFNdkIsUUFBUU8sYUFBYXlCLE9BQU8sQ0FBQztRQUNuQyxPQUFPLENBQUMsQ0FBQ2hDO0lBQ1g7SUFFQTs7R0FFQyxHQUNELFNBQXNCO1FBQ3BCLElBQUksS0FBNkIsRUFBRSxFQUVsQztRQUVETyxhQUFhMkIsVUFBVSxDQUFDO1FBQ3hCM0IsYUFBYTJCLFVBQVUsQ0FBQztJQUMxQjtJQUVBOzs7R0FHQyxHQUNELGFBQW1DO1FBQ2pDLElBQUksS0FBNkIsRUFBRSxFQUVsQztRQUVELE9BQU8zQixhQUFheUIsT0FBTyxDQUFDO0lBQzlCO0lBRUE7OztHQUdDLEdBQ0QsZUFBMkI7UUFDekIsSUFBSSxLQUE2QixFQUFFLEVBRWxDO1FBRUQsTUFBTUssY0FBYzlCLGFBQWF5QixPQUFPLENBQUM7UUFDekMsSUFBSSxDQUFDSyxhQUFhO1lBQ2hCLE9BQU87UUFDVDtRQUVBLElBQUk7WUFDRixPQUFPNUIsS0FBSzZCLEtBQUssQ0FBQ0Q7UUFDcEIsRUFBRSxPQUFPZCxNQUFNO1lBQ2IvQixRQUFRZ0MsS0FBSyxDQUFDLG1DQUFtQ0Q7WUFDakQsT0FBTztRQUNUO0lBQ0Y7SUFyVUEsYUFBYztRQUNaLGtDQUFrQztRQUNsQyxJQUFJLENBQUNSLE9BQU8sR0FBR3dCLE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0Msd0JBQXdCLElBQUk7UUFFdkQsd0ZBQXdGO1FBQ3hGLElBQUksQ0FBQ2xELGFBQWEsR0FBR2dELE9BQU9BLENBQUNDLEdBQUcsQ0FBQ0UsMEJBQTBCLEtBQUssVUFBVTtRQUUxRSxpQ0FBaUM7UUFDakMsSUFBSSxDQUFDNUMsaUJBQWlCLEdBQUc7WUFDdkIscUJBQXFCO2dCQUFFYyxNQUFNO2dCQUFpQnZCLE9BQU87Z0JBQXFCQyxPQUFPO1lBQVc7WUFDNUYsMEJBQTBCO2dCQUFFc0IsTUFBTTtnQkFBb0J2QixPQUFPO2dCQUEwQkMsT0FBTztZQUFXO1lBQ3pHLDZCQUE2QjtnQkFBRXNCLE1BQU07Z0JBQXVCdkIsT0FBTztnQkFBNkJDLE9BQU87WUFBVztRQUNwSDtJQUNGO0FBeVRGIiwic291cmNlcyI6WyJDOlxcZ2loaHViXFxwdWxzZWh1Ylxcc3JjXFxmcm9udC1lbmRcXHNlcnZpY29zXFxTZXJ2aWNvQXV0ZW50aWNhY2FvLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBTZXJ2acOnbyBkZSBhdXRlbnRpY2HDp8OjbyBwYXJhIG8gZnJvbnQtZW5kXHJcbiAqIFJlc3BvbnPDoXZlbCBwb3IgY29tdW5pY2HDp8OjbyBjb20gbyBNQ1AgZGUgYXV0ZW50aWNhw6fDo29cclxuICovXHJcbmV4cG9ydCBjbGFzcyBTZXJ2aWNvQXV0ZW50aWNhY2FvIHtcclxuICBwcml2YXRlIGJhc2VVcmw6IHN0cmluZztcclxuICBwcml2YXRlIG1vZG9TaW11bGFjYW86IGJvb2xlYW47XHJcbiAgcHJpdmF0ZSB1c3Vhcmlvc1NpbXVsYWRvczogeyBbZW1haWw6IHN0cmluZ106IHsgbm9tZTogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCBzZW5oYTogc3RyaW5nIH0gfTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAvLyBVUkwgYmFzZSBkbyBNQ1AgZGUgYXV0ZW50aWNhw6fDo29cclxuICAgIHRoaXMuYmFzZVVybCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FVVEhfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcclxuICAgIFxyXG4gICAgLy8gVmVyaWZpY2FyIHNlIGRldmVtb3MgdXNhciBvIG1vZG8gZGUgc2ltdWxhw6fDo28gKHF1YW5kbyBvIHNlcnZpZG9yIG7Do28gZXN0w6EgZGlzcG9uw612ZWwpXHJcbiAgICB0aGlzLm1vZG9TaW11bGFjYW8gPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19NT0RPX1NJTVVMQUNBTyA9PT0gJ3RydWUnIHx8IHRydWU7XHJcbiAgICBcclxuICAgIC8vIFVzdcOhcmlvcyBzaW11bGFkb3MgcGFyYSB0ZXN0ZXNcclxuICAgIHRoaXMudXN1YXJpb3NTaW11bGFkb3MgPSB7XHJcbiAgICAgICdhZG1pbkBleGVtcGxvLmNvbSc6IHsgbm9tZTogJ0FkbWluaXN0cmFkb3InLCBlbWFpbDogJ2FkbWluQGV4ZW1wbG8uY29tJywgc2VuaGE6ICdzZW5oYTEyMycgfSxcclxuICAgICAgJ2Zvcm5lY2Vkb3JAZXhlbXBsby5jb20nOiB7IG5vbWU6ICdGb3JuZWNlZG9yIFRlc3RlJywgZW1haWw6ICdmb3JuZWNlZG9yQGV4ZW1wbG8uY29tJywgc2VuaGE6ICdzZW5oYTEyMycgfSxcclxuICAgICAgJ3JlcHJlc2VudGFudGVAZXhlbXBsby5jb20nOiB7IG5vbWU6ICdSZXByZXNlbnRhbnRlIFRlc3RlJywgZW1haWw6ICdyZXByZXNlbnRhbnRlQGV4ZW1wbG8uY29tJywgc2VuaGE6ICdzZW5oYTEyMycgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlYWxpemEgbyBsb2dpbiBkbyB1c3XDoXJpb1xyXG4gICAqIEBwYXJhbSBlbWFpbCBFbWFpbCBkbyB1c3XDoXJpb1xyXG4gICAqIEBwYXJhbSBzZW5oYSBTZW5oYSBkbyB1c3XDoXJpb1xyXG4gICAqIEByZXR1cm5zIFRva2VuIEpXVCBlbSBjYXNvIGRlIHN1Y2Vzc29cclxuICAgKiBAdGhyb3dzIEVycm9yIGVtIGNhc28gZGUgZmFsaGFcclxuICAgKi9cclxuICBwdWJsaWMgYXN5bmMgbG9naW4oZW1haWw6IHN0cmluZywgc2VuaGE6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICAvLyBTZSBlc3RpdmVyIGVtIG1vZG8gZGUgc2ltdWxhw6fDo28sIHVzYXIgZGFkb3Mgc2ltdWxhZG9zXHJcbiAgICBpZiAodGhpcy5tb2RvU2ltdWxhY2FvKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdVc2FuZG8gbW9kbyBkZSBzaW11bGHDp8OjbyBwYXJhIGxvZ2luJyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTaW11bGFyIHVtIHBlcXVlbm8gYXRyYXNvIHBhcmEgcGFyZWNlciB1bWEgcmVxdWlzacOnw6NvIHJlYWxcclxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdXN1YXJpbyA9IHRoaXMudXN1YXJpb3NTaW11bGFkb3NbZW1haWxdO1xyXG4gICAgICBcclxuICAgICAgaWYgKCF1c3VhcmlvKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc3XDoXJpbyBuw6NvIGVuY29udHJhZG8nKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgaWYgKHVzdWFyaW8uc2VuaGEgIT09IHNlbmhhKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZW5oYSBpbmNvcnJldGEnKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gR2VyYXIgdW0gdG9rZW4gc2ltdWxhZG9cclxuICAgICAgY29uc3QgdG9rZW4gPSBgc2ltdWxhZG8tJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSl9YDtcclxuICAgICAgXHJcbiAgICAgIC8vIEFybWF6ZW5hciBvIHRva2VuIG5vIGxvY2FsU3RvcmFnZVxyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndG9rZW4nLCB0b2tlbik7XHJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c3VhcmlvJywgSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICAgIGlkOiBgdXNlci0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KX1gLFxyXG4gICAgICAgIG5vbWU6IHVzdWFyaW8ubm9tZSxcclxuICAgICAgICBlbWFpbDogdXN1YXJpby5lbWFpbFxyXG4gICAgICB9KSk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gdG9rZW47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNlIG7Do28gZXN0aXZlciBlbSBtb2RvIGRlIHNpbXVsYcOnw6NvLCB0ZW50YXIgY29uZWN0YXIgYW8gc2Vydmlkb3IgcmVhbFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9zdGEgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L2xvZ2luYCwge1xyXG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IGVtYWlsLCBzZW5oYSB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBkYWRvcyA9IGF3YWl0IHJlc3Bvc3RhLmpzb24oKTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9zdGEub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGFkb3MubWVzc2FnZSB8fCAnRXJybyBhbyByZWFsaXphciBsb2dpbicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBcm1hemVuYXIgbyB0b2tlbiBubyBsb2NhbFN0b3JhZ2VcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rva2VuJywgZGFkb3MudG9rZW4pO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGRhZG9zLnRva2VuO1xyXG4gICAgfSBjYXRjaCAoZXJybykge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvIG5vIGxvZ2luOicsIGVycm8pO1xyXG4gICAgICBcclxuICAgICAgLy8gU2UgbyBlcnJvIGZvciBkZSBjb25leMOjbywgdGVudGFyIHVzYXIgbyBtb2RvIGRlIHNpbXVsYcOnw6NvXHJcbiAgICAgIGlmIChlcnJvIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm8ubWVzc2FnZS5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnU2Vydmlkb3IgaW5kaXNwb27DrXZlbCwgYWx0ZXJuYW5kbyBwYXJhIG1vZG8gZGUgc2ltdWxhw6fDo28nKTtcclxuICAgICAgICB0aGlzLm1vZG9TaW11bGFjYW8gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvZ2luKGVtYWlsLCBzZW5oYSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHRocm93IGVycm87XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RyYSB1bSBub3ZvIHVzdcOhcmlvXHJcbiAgICogQHBhcmFtIG5vbWUgTm9tZSBkbyB1c3XDoXJpb1xyXG4gICAqIEBwYXJhbSBlbWFpbCBFbWFpbCBkbyB1c3XDoXJpb1xyXG4gICAqIEBwYXJhbSBzZW5oYSBTZW5oYSBkbyB1c3XDoXJpb1xyXG4gICAqIEByZXR1cm5zIERhZG9zIGRvIHVzdcOhcmlvIGNyaWFkb1xyXG4gICAqIEB0aHJvd3MgRXJyb3IgZW0gY2FzbyBkZSBmYWxoYVxyXG4gICAqL1xyXG4gIHB1YmxpYyBhc3luYyByZWdpc3RyYXIobm9tZTogc3RyaW5nLCBlbWFpbDogc3RyaW5nLCBzZW5oYTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIC8vIFNlIGVzdGl2ZXIgZW0gbW9kbyBkZSBzaW11bGHDp8OjbywgdXNhciBkYWRvcyBzaW11bGFkb3NcclxuICAgIGlmICh0aGlzLm1vZG9TaW11bGFjYW8pIHtcclxuICAgICAgY29uc29sZS5sb2coJ1VzYW5kbyBtb2RvIGRlIHNpbXVsYcOnw6NvIHBhcmEgcmVnaXN0cm8nKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFNpbXVsYXIgdW0gcGVxdWVubyBhdHJhc28gcGFyYSBwYXJlY2VyIHVtYSByZXF1aXNpw6fDo28gcmVhbFxyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgNTAwKSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBWZXJpZmljYXIgc2UgbyBlbWFpbCBqw6EgZXN0w6EgZW0gdXNvXHJcbiAgICAgIGlmICh0aGlzLnVzdWFyaW9zU2ltdWxhZG9zW2VtYWlsXSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXN0ZSBlbWFpbCBqw6EgZXN0w6EgZW0gdXNvJyk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEFkaWNpb25hciBvIG5vdm8gdXN1w6FyaW8gw6AgbGlzdGEgZGUgdXN1w6FyaW9zIHNpbXVsYWRvc1xyXG4gICAgICB0aGlzLnVzdWFyaW9zU2ltdWxhZG9zW2VtYWlsXSA9IHsgbm9tZSwgZW1haWwsIHNlbmhhIH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBSZXRvcm5hciBvcyBkYWRvcyBkbyB1c3XDoXJpbyBjcmlhZG8gKHNlbSBhIHNlbmhhKVxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBgdXNlci0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KX1gLFxyXG4gICAgICAgIG5vbWUsXHJcbiAgICAgICAgZW1haWwsXHJcbiAgICAgICAgbWVzc2FnZTogJ1VzdcOhcmlvIHJlZ2lzdHJhZG8gY29tIHN1Y2Vzc28hJ1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTZSBuw6NvIGVzdGl2ZXIgZW0gbW9kbyBkZSBzaW11bGHDp8OjbywgdGVudGFyIGNvbmVjdGFyIGFvIHNlcnZpZG9yIHJlYWxcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3Bvc3RhID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9yZWdpc3RyYXJgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbm9tZSwgZW1haWwsIHNlbmhhIH0pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGRhZG9zID0gYXdhaXQgcmVzcG9zdGEuanNvbigpO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb3N0YS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYWRvcy5tZXNzYWdlIHx8ICdFcnJvIGFvIHJlZ2lzdHJhciB1c3XDoXJpbycpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGFkb3M7XHJcbiAgICB9IGNhdGNoIChlcnJvKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm8gbm8gcmVnaXN0cm86JywgZXJybyk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBTZSBvIGVycm8gZm9yIGRlIGNvbmV4w6NvLCB0ZW50YXIgdXNhciBvIG1vZG8gZGUgc2ltdWxhw6fDo29cclxuICAgICAgaWYgKGVycm8gaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyby5tZXNzYWdlLmluY2x1ZGVzKCdGYWlsZWQgdG8gZmV0Y2gnKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdTZXJ2aWRvciBpbmRpc3BvbsOtdmVsLCBhbHRlcm5hbmRvIHBhcmEgbW9kbyBkZSBzaW11bGHDp8OjbycpO1xyXG4gICAgICAgIHRoaXMubW9kb1NpbXVsYWNhbyA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cmFyKG5vbWUsIGVtYWlsLCBzZW5oYSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHRocm93IGVycm87XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTb2xpY2l0YSByZWN1cGVyYcOnw6NvIGRlIHNlbmhhXHJcbiAgICogQHBhcmFtIGVtYWlsIEVtYWlsIGRvIHVzdcOhcmlvXHJcbiAgICogQHJldHVybnMgTWVuc2FnZW0gZGUgc3VjZXNzb1xyXG4gICAqIEB0aHJvd3MgRXJyb3IgZW0gY2FzbyBkZSBmYWxoYVxyXG4gICAqL1xyXG4gIHB1YmxpYyBhc3luYyByZWN1cGVyYXJTZW5oYShlbWFpbDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIC8vIFNlIGVzdGl2ZXIgZW0gbW9kbyBkZSBzaW11bGHDp8OjbywgdXNhciBkYWRvcyBzaW11bGFkb3NcclxuICAgIGlmICh0aGlzLm1vZG9TaW11bGFjYW8pIHtcclxuICAgICAgY29uc29sZS5sb2coJ1VzYW5kbyBtb2RvIGRlIHNpbXVsYcOnw6NvIHBhcmEgcmVjdXBlcmHDp8OjbyBkZSBzZW5oYScpO1xyXG4gICAgICBcclxuICAgICAgLy8gU2ltdWxhciB1bSBwZXF1ZW5vIGF0cmFzbyBwYXJhIHBhcmVjZXIgdW1hIHJlcXVpc2nDp8OjbyByZWFsXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFZlcmlmaWNhciBzZSBvIGVtYWlsIGV4aXN0ZVxyXG4gICAgICBpZiAoIXRoaXMudXN1YXJpb3NTaW11bGFkb3NbZW1haWxdKSB7XHJcbiAgICAgICAgLy8gUG9yIHNlZ3VyYW7Dp2EsIG7Do28gaW5mb3JtYW1vcyBzZSBvIGVtYWlsIGV4aXN0ZSBvdSBuw6NvXHJcbiAgICAgICAgcmV0dXJuICdTZSBvIGUtbWFpbCBlc3RpdmVyIGNhZGFzdHJhZG8sIGVudmlhcmVtb3MgaW5zdHJ1w6fDtWVzIHBhcmEgcmVjdXBlcmHDp8OjbyBkZSBzZW5oYS4nO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTaW11bGFyIHVtIHRva2VuIGRlIHJlY3VwZXJhw6fDo29cclxuICAgICAgY29uc3QgdG9rZW4gPSBgcmVjdXBlcmFjYW8tJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxNSl9YDtcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBUb2tlbiBkZSByZWN1cGVyYcOnw6NvIHNpbXVsYWRvIHBhcmEgJHtlbWFpbH06ICR7dG9rZW59YCk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gJ1NlIG8gZS1tYWlsIGVzdGl2ZXIgY2FkYXN0cmFkbywgZW52aWFyZW1vcyBpbnN0cnXDp8O1ZXMgcGFyYSByZWN1cGVyYcOnw6NvIGRlIHNlbmhhLic7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNlIG7Do28gZXN0aXZlciBlbSBtb2RvIGRlIHNpbXVsYcOnw6NvLCB0ZW50YXIgY29uZWN0YXIgYW8gc2Vydmlkb3IgcmVhbFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9zdGEgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9L3JlY3VwZXJhci1zZW5oYWAsIHtcclxuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoeyBlbWFpbCB9KSxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBjb25zdCBkYWRvcyA9IGF3YWl0IHJlc3Bvc3RhLmpzb24oKTtcclxuXHJcbiAgICAgIGlmICghcmVzcG9zdGEub2spIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGFkb3MubWVzc2FnZSB8fCAnRXJybyBhbyBzb2xpY2l0YXIgcmVjdXBlcmHDp8OjbyBkZSBzZW5oYScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGFkb3MubWVzc2FnZTtcclxuICAgIH0gY2F0Y2ggKGVycm8pIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJybyBuYSByZWN1cGVyYcOnw6NvIGRlIHNlbmhhOicsIGVycm8pO1xyXG4gICAgICBcclxuICAgICAgLy8gU2UgbyBlcnJvIGZvciBkZSBjb25leMOjbywgdGVudGFyIHVzYXIgbyBtb2RvIGRlIHNpbXVsYcOnw6NvXHJcbiAgICAgIGlmIChlcnJvIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm8ubWVzc2FnZS5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnU2Vydmlkb3IgaW5kaXNwb27DrXZlbCwgYWx0ZXJuYW5kbyBwYXJhIG1vZG8gZGUgc2ltdWxhw6fDo28nKTtcclxuICAgICAgICB0aGlzLm1vZG9TaW11bGFjYW8gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlY3VwZXJhclNlbmhhKGVtYWlsKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhyb3cgZXJybztcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZGVmaW5lIGEgc2VuaGEgZG8gdXN1w6FyaW9cclxuICAgKiBAcGFyYW0gc2VuaGEgTm92YSBzZW5oYVxyXG4gICAqIEBwYXJhbSB0b2tlbiBUb2tlbiBkZSByZWRlZmluacOnw6NvIGRlIHNlbmhhXHJcbiAgICogQHJldHVybnMgTWVuc2FnZW0gZGUgc3VjZXNzb1xyXG4gICAqIEB0aHJvd3MgRXJyb3IgZW0gY2FzbyBkZSBmYWxoYVxyXG4gICAqL1xyXG4gIHB1YmxpYyBhc3luYyByZWRlZmluaXJTZW5oYShzZW5oYTogc3RyaW5nLCB0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIC8vIFNlIGVzdGl2ZXIgZW0gbW9kbyBkZSBzaW11bGHDp8OjbywgdXNhciBkYWRvcyBzaW11bGFkb3NcclxuICAgIGlmICh0aGlzLm1vZG9TaW11bGFjYW8pIHtcclxuICAgICAgY29uc29sZS5sb2coJ1VzYW5kbyBtb2RvIGRlIHNpbXVsYcOnw6NvIHBhcmEgcmVkZWZpbmnDp8OjbyBkZSBzZW5oYScpO1xyXG4gICAgICBcclxuICAgICAgLy8gU2ltdWxhciB1bSBwZXF1ZW5vIGF0cmFzbyBwYXJhIHBhcmVjZXIgdW1hIHJlcXVpc2nDp8OjbyByZWFsXHJcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFZlcmlmaWNhciBzZSBvIHRva2VuIMOpIHbDoWxpZG8gKGVtIHVtIGNhc28gcmVhbCwgdmVyaWZpY2Fyw61hbW9zIGVtIHVtIGJhbmNvIGRlIGRhZG9zKVxyXG4gICAgICBpZiAoIXRva2VuLnN0YXJ0c1dpdGgoJ3JlY3VwZXJhY2FvLScpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiBpbnbDoWxpZG8gb3UgZXhwaXJhZG8nKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRW0gdW0gY2FzbyByZWFsLCBhdHVhbGl6YXLDrWFtb3MgYSBzZW5oYSBkbyB1c3XDoXJpbyBubyBiYW5jbyBkZSBkYWRvc1xyXG4gICAgICBjb25zb2xlLmxvZyhgU2VuaGEgcmVkZWZpbmlkYSBjb20gc3VjZXNzbyB1c2FuZG8gbyB0b2tlbjogJHt0b2tlbn1gKTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiAnU2VuaGEgcmVkZWZpbmlkYSBjb20gc3VjZXNzbyEnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTZSBuw6NvIGVzdGl2ZXIgZW0gbW9kbyBkZSBzaW11bGHDp8OjbywgdGVudGFyIGNvbmVjdGFyIGFvIHNlcnZpZG9yIHJlYWxcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3Bvc3RhID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9yZWRlZmluaXItc2VuaGFgLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgc2VuaGEsIHRva2VuIH0pLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGRhZG9zID0gYXdhaXQgcmVzcG9zdGEuanNvbigpO1xyXG5cclxuICAgICAgaWYgKCFyZXNwb3N0YS5vaykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkYWRvcy5tZXNzYWdlIHx8ICdFcnJvIGFvIHJlZGVmaW5pciBzZW5oYScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZGFkb3MubWVzc2FnZTtcclxuICAgIH0gY2F0Y2ggKGVycm8pIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJybyBuYSByZWRlZmluacOnw6NvIGRlIHNlbmhhOicsIGVycm8pO1xyXG4gICAgICBcclxuICAgICAgLy8gU2UgbyBlcnJvIGZvciBkZSBjb25leMOjbywgdGVudGFyIHVzYXIgbyBtb2RvIGRlIHNpbXVsYcOnw6NvXHJcbiAgICAgIGlmIChlcnJvIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm8ubWVzc2FnZS5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnU2Vydmlkb3IgaW5kaXNwb27DrXZlbCwgYWx0ZXJuYW5kbyBwYXJhIG1vZG8gZGUgc2ltdWxhw6fDo28nKTtcclxuICAgICAgICB0aGlzLm1vZG9TaW11bGFjYW8gPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlZGVmaW5pclNlbmhhKHNlbmhhLCB0b2tlbik7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHRocm93IGVycm87XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWZXJpZmljYSBzZSBvIHVzdcOhcmlvIGVzdMOhIGF1dGVudGljYWRvXHJcbiAgICogQHJldHVybnMgdHJ1ZSBzZSBvIHVzdcOhcmlvIGVzdGl2ZXIgYXV0ZW50aWNhZG8sIGZhbHNlIGNhc28gY29udHLDoXJpb1xyXG4gICAqL1xyXG4gIHB1YmxpYyBlc3RhQXV0ZW50aWNhZG8oKTogYm9vbGVhbiB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xyXG4gICAgcmV0dXJuICEhdG9rZW47XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWFsaXphIG8gbG9nb3V0IGRvIHVzdcOhcmlvXHJcbiAgICovXHJcbiAgcHVibGljIGxvZ291dCgpOiB2b2lkIHtcclxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd0b2tlbicpO1xyXG4gICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzdWFyaW8nKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9idMOpbSBvIHRva2VuIEpXVCBhcm1hemVuYWRvXHJcbiAgICogQHJldHVybnMgVG9rZW4gSldUIG91IG51bGwgc2UgbsOjbyBlc3RpdmVyIGF1dGVudGljYWRvXHJcbiAgICovXHJcbiAgcHVibGljIG9idGVyVG9rZW4oKTogc3RyaW5nIHwgbnVsbCB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcclxuICB9XHJcbiAgXHJcbiAgLyoqXHJcbiAgICogT2J0w6ltIG9zIGRhZG9zIGRvIHVzdcOhcmlvIGF1dGVudGljYWRvXHJcbiAgICogQHJldHVybnMgRGFkb3MgZG8gdXN1w6FyaW8gb3UgbnVsbCBzZSBuw6NvIGVzdGl2ZXIgYXV0ZW50aWNhZG9cclxuICAgKi9cclxuICBwdWJsaWMgb2J0ZXJVc3VhcmlvKCk6IGFueSB7XHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IHVzdWFyaW9Kc29uID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzdWFyaW8nKTtcclxuICAgIGlmICghdXN1YXJpb0pzb24pIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHVzdWFyaW9Kc29uKTtcclxuICAgIH0gY2F0Y2ggKGVycm8pIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJybyBhbyBvYnRlciBkYWRvcyBkbyB1c3XDoXJpbzonLCBlcnJvKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG59Il0sIm5hbWVzIjpbIlNlcnZpY29BdXRlbnRpY2FjYW8iLCJsb2dpbiIsImVtYWlsIiwic2VuaGEiLCJtb2RvU2ltdWxhY2FvIiwiY29uc29sZSIsImxvZyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsInVzdWFyaW8iLCJ1c3Vhcmlvc1NpbXVsYWRvcyIsIkVycm9yIiwidG9rZW4iLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJpZCIsIm5vbWUiLCJyZXNwb3N0YSIsImZldGNoIiwiYmFzZVVybCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiZGFkb3MiLCJqc29uIiwib2siLCJtZXNzYWdlIiwiZXJybyIsImVycm9yIiwiVHlwZUVycm9yIiwiaW5jbHVkZXMiLCJyZWdpc3RyYXIiLCJyZWN1cGVyYXJTZW5oYSIsInJlZGVmaW5pclNlbmhhIiwic3RhcnRzV2l0aCIsImVzdGFBdXRlbnRpY2FkbyIsImdldEl0ZW0iLCJsb2dvdXQiLCJyZW1vdmVJdGVtIiwib2J0ZXJUb2tlbiIsIm9idGVyVXN1YXJpbyIsInVzdWFyaW9Kc29uIiwicGFyc2UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVVUSF9BUElfVVJMIiwiTkVYVF9QVUJMSUNfTU9ET19TSU1VTEFDQU8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./src/front-end/servicos/ServicoAutenticacao.ts\n"));

/***/ })

});